\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% Basic packages
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{tabularx}
\usepackage{amsmath}

% Simple code listing setup
\lstset{
    backgroundcolor=\color{gray!10},
    basicstyle=\ttfamily\small,
    breaklines=true,
    numbers=left,
    frame=single
}

\begin{document}

\title{\textbf{MiniSoft Compiler Implementation}}
\author{HADJ ARAB Adel \and RACHEDI Abderrahmane}
\date{\today}
\maketitle

\begin{abstract}
	This report details the design and implementation of a compiler for the MiniSoft language using Rust with LALRPOP for syntax analysis and Logos for lexical analysis. The compiler supports the full MiniSoft language specification and implements all compilation phases from lexical analysis to code generation.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}
\subsection{Project Overview}
This project involves the development of a compiler for the MiniSoft programming language, implemented using the Rust programming language. A compiler is a specialized software tool that translates human-readable source code into machine-executable instructions. The MiniSoft compiler represents an implementation that handles four phases of the compilation process, from initial code analysis to the generation quadruples.

The primary goal of this project is to create a fully functional compiler that correctly implements the MiniSoft language specification while demonstrating modern compiler design principles. This includes robust error handling, and a modular architecture that separates the compilation process into distinct phases.

\subsection{MiniSoft Language Features}
MiniSoft is a compact programming language designed for educational purposes, combining simplicity with a range of essential programming features:

\begin{itemize}
	\item \textbf{Variables and Data Types}: MiniSoft supports three primary data types: integers (from -32768 to 32767), floating-point numbers (decimals).

	\item \textbf{Arrays}: The language supports single-dimensional arrays for each basic data type.

	\item \textbf{Expressions and Operators}: MiniSoft includes operators for arithmetic calculations, comparisons, and logical operations.

	\item \textbf{Control Flow Structures}: Programmers can use conditional statements (if-then-else) and iterative constructs (do-while and for loops).

	\item \textbf{Constants}: The language allows the definition of named constants.

	\item \textbf{Input/Output Operations}: MiniSoft provides basic facilities for console I/O.

	\item \textbf{Type System}: MiniSoft employs a static type system, with variable types determined at compile time.
\end{itemize}

Each MiniSoft program consists of a main program block with variable declarations followed by executable statements.

\subsection{Tools and Technologies}
The MiniSoft compiler is built using modern tools that enable efficient implementation:

\begin{itemize}
	\item \textbf{Rust Programming Language}: Chosen for its memory safety, performance, and pattern matching capabilities.
    
	\item \textbf{Logos}: A high-performance lexer generator for Rust with attribute-based syntax for defining tokens.
    
	\item \textbf{LALRPOP}: A parser generator for Rust that allows expressing grammar rules in a declarative forma parser generator for Rust that uses the LR(1) parsing algorithm, enabling developers to define grammar rules declaratively.

	\item \textbf{Cranelift}: A code generator framework used to produce optimized machine code.
\end{itemize}

\begin{figure}[H]
	\centering
	% \includegraphics[width=0.8\textwidth]{compiler_architecture.png}
	\caption{MiniSoft Compiler Architecture showing the flow from source code through lexical analysis, syntax analysis, semantic analysis, and code generation.}
	\label{fig:compiler-architecture}
\end{figure}

\section{Compiler Design}
\subsection{Compilation Pipeline}
The MiniSoft compiler follows the classical compiler pipeline architecture, divided into sequential phases:

\begin{enumerate}
	\item \textbf{Lexical Analysis (Scanning)}: Reads source code character by character and groups characters into tokens such as keywords, identifiers, literals, and operators.

	\item \textbf{Syntax Analysis (Parsing)}: Analyzes the sequence of tokens to determine if they follow the MiniSoft grammar rules, building an Abstract Syntax Tree (AST).

	\item \textbf{Semantic Analysis}: Checks whether the program makes logical sense, including type checking, scope validation, and constant analysisvalidates program logic through declaration, statement, and expression analysis, covering type checking, scope rules, and constant evaluation..

	\item \textbf{Intermediate Code Generation}: Translates the AST into an intermediate representation using quadruples.
\end{enumerate}

\subsection{Architecture Overview}
The MiniSoft compiler uses a modular architecture with components that correspond to the phases of compilation:

\begin{itemize}
	\item \textbf{Core Compiler Driver}: Orchestrates the compilation process and handles high-level error reporting.

	\item \textbf{Lexer Module}: Implements lexical analysis using Logos to convert source text into tokens.

	\item \textbf{Parser Module}: Uses LALRPOP to implement syntax analysis, converting tokens into AST.

	\item \textbf{Semantic Analyzer}: Performs type checking, scope analysis, and other semantic validations.

	\item \textbf{Code Generator}: Translates validated AST into executable code.

	\item \textbf{Error Handling System}: Provides unified error reporting across all compiler phases.
\end{itemize}

\subsection{Design Decisions}
Key design decisions that shaped the implementation include:

\begin{itemize}
	\item \textbf{Strong Error Reporting}: Prioritizing comprehensive error detection and clear, actionable messages.

	\item \textbf{Location-Aware AST}: Each node carries source location information for precise error reporting.

	\item \textbf{Type Safety Through Rust}: Leveraging Rust's type system to prevent implementation errors.

	\item \textbf{Progressive Validation}: Each compilation phase assumes previous validations have passed.

	\item \textbf{Early Error Detection}: Detecting potential runtime errors at compile time when possible.

	\item \textbf{Intermediate Representation Choice}: Using quadruples for their simplicity and expressiveness.

	\item \textbf{Declaration-Before-Use Requirement}: Requiring variable declarations before use to simplify analysis.
\end{itemize}

These decisions reflect a balance between educational value, implementation practicality, and user experience.

\section{Lexical Analysis}
\subsection{Overview of Lexical Analysis}
Lexical analysis, the first phase of compilation, transforms source code into tokensâ€”the smallest meaningful units of a programming language. In the MiniSoft compiler, this phase is implemented using Logos, which combines declarative syntax with efficient processing.

The lexical analyzer (lexer) scans the input character by character, following two core rules:

\begin{itemize}
    \item \textbf{Longest Match Rule}: Prioritizes the longest possible valid token (e.g., \texttt{>=} over \texttt{>}).
    
    \item \textbf{Priority Rule}: Resolves ambiguities by matching the first declared pattern (e.g., keywords before identifiers).
\end{itemize}

The lexer recognizes token patterns while filtering out non-essential elements like whitespace and comments.

\subsection{Token Design}
The MiniSoft language employs a comprehensive token classification system:

\begin{itemize}
	\item \textbf{Keywords}: Reserved words \texttt{MainPrgm}, \texttt{Var}, \texttt{BeginPg}, \texttt{EndPg}, \texttt{let}, \texttt{Int}, \texttt{Float}, \texttt{if}, \texttt{then}, \texttt{else}, \texttt{while}, \texttt{for}, \texttt{do}, \texttt{from}, \texttt{to}, \texttt{step}, \texttt{input}, \texttt{output}, \texttt{@define}, \texttt{Const}
	\item \textbf{Control flow structures}: Tokens \texttt{if}, \texttt{then}, \texttt{else}, \texttt{while}, \texttt{for}, \texttt{do}, \texttt{from}, \texttt{to}, \texttt{step}
	\item \textbf{Declarations}: Tokens \texttt{let}, \texttt{Int}, \texttt{Float}, \texttt{Const}
	\item \textbf{Program structure}: Tokens \texttt{MainPrgm}, \texttt{Var}, \texttt{BeginPg}, \texttt{EndPg}
	\item \textbf{Operators}: Arithmetic \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, comparison \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=}, \texttt{==}, \texttt{!=}, and logical operators \texttt{AND}, \texttt{OR}.
	\item \textbf{Punctuation}: Symbols \texttt{;}, \texttt{,}, \texttt{:}, \texttt{[}, \texttt{]}, \texttt{{} , \texttt{}}, \texttt{(}, \texttt{)}
	\item \textbf{Literals}: Integer, floating-point, and string values
	\item \textbf{Identifiers}: User-defined names
\end{itemize}

Each token carries metadata including the original text, line number, column position, and character span.

\begin{lstlisting}[caption={Token Structure}]
#[derive(Debug, Clone, PartialEq)]
pub struct TokenWithMetaData {
    pub kind: Token,     // The token's type
    pub value: String,   // The actual text from source code
    pub line: usize,     // Line number in source
    pub column: usize,   // Column position
    pub span: Range<usize>, // Character span in source
}
\end{lstlisting}

\subsection{Lexer Implementation with Logos}
The MiniSoft lexer uses Logos' declarative approach to define token patterns:

\begin{lstlisting}[caption={Logos Token Definitions Syntax}]
#[pattern_type("matching_rule", processing_callback)]
TokenVariant(OutputType)
\end{lstlisting}

\begin{lstlisting}[caption={Sample Token Definitions}]
    #[derive(Logos, Debug, PartialEq, Clone)]
    #[logos(extras = Line)]
    pub enum Token {
        // Whitespace handling
        #[regex(r"[ \t\f\r]+", logos::skip)]
        #[regex(r"\n", newline_callback)]
        
        // Keywords
        #[token("MainPrgm")]
        MainPrgm,
        #[token("BeginPg")]
        BeginPg,
        #[token("if")]
        If,
        
        // Literals
        #[regex("[0-9]+", parse_int_literal)]
        IntLiteral(i32),
        
        #[regex("\"[^\"]*\"", parse_string_literal)]
        StringLiteral(String),
        
    }
    \end{lstlisting}

This approach makes the lexer's behavior clear and maintainable, with different token types handled through specific patterns and callbacks.

\subsection{Handling Special Cases}
The MiniSoft lexer implements careful processing for language-specific requirements:

\subsubsection{Identifiers with Rules}
Identifiers in MiniSoft have specific constraints:
\begin{itemize}
	\item Maximum length of 14 characters
	\item No consecutive underscores
	\item No trailing underscores
	\item Only the first character may be uppercase
	\item Must start with a letter
\end{itemize}

\begin{lstlisting}[caption={Identifier Validation}]
fn parse_identifier(lex: &mut logos::Lexer<Token>) -> Option<String> {
    let s = lex.slice();
    let has_uppercase_after_first = s.chars().skip(1).any(|c| c.is_ascii_uppercase());

    if s.len() <= 14 && !s.contains("__") && !s.ends_with("_") && !has_uppercase_after_first {
        Some(s.to_string())
    } else {
        None
    }
}
\end{lstlisting}

\subsubsection{Comments}
MiniSoft supports two comment styles:
\begin{itemize}
	\item C-style comments: \texttt{\{--comment--\}}
	\item XML-style comments: \texttt{<!-- comment -->}
\end{itemize}

\begin{lstlisting}[caption={Comment Handling}]
    // Comments (ignored)
    #[regex("<\\!-([^-\n]|(-[^!\n]))*-\\!>", logos::skip)]
    Comment,
\end{lstlisting}

\subsection{Error Handling and Reporting}
The lexer detects and aggregates all lexical errors during tokenization, halting compilation upon encountering any such errors to ensure early failure.

\begin{lstlisting}[caption={Lexical Error Types}]
#[derive(Debug, Clone, PartialEq)]
pub enum LexicalErrorType {
    UnterminatedString,
    NonAsciiCharacters,
    IdentifierTooLong,
    InvalidIdentifier,
    ConsecutiveUnderscores,
    TrailingUnderscore,
    IdentifierStartsWithNumber,
    IntegerOutOfRange,
    SignedNumberNotParenthesized,
    InvalidToken,
}
\end{lstlisting}

When errors are found, the lexer creates detailed messages with exact positions, problematic text, and suggestions for fixing issues.

\begin{lstlisting}[caption={Sample Error Output}]
Lexical Error: Identifier 'myVeryLongVariableName' exceeds maximum length of 14 characters
--> line 3, column 5
  |
3 | let myVeryLongVariableName = 10;
  |     ^^^^^^^^^^^^^^^^^^^^^^ 
Suggestion: Identifiers must be 14 characters or less
\end{lstlisting}

\section{Syntax Analysis}
\subsection{Overview of Syntax Analysis}
Syntax analysis determines whether tokens form valid language constructs according to the grammar rules. In the MiniSoft compiler, this phase is implemented using LALRPOP, which allows expressing grammar rules in a readable format.

The parser verifies that tokens follow grammatical rules, detects syntax errors, and organizes tokens into an Abstract Syntax Tree (AST).


\subsection{Grammer  for  Syntax Analysis}
The MiniSoft grammar is formally defined as LR(1) production rules with embedded semantic actions, ensuring unambiguous parsing and full language coverage.

\begin{equation*}
    G = (N, T, S, P)
    \end{equation*}
    
    \subsubsection*{Components:}
    \begin{itemize}
        \item \textbf{Non-Terminals (N):} Grammar variables
        \item \textbf{Terminals (T):} Language tokens
        \item \textbf{Start Symbol (S):} Program
        \item \textbf{Productions (P):} Derivation rules
    \end{itemize}
    
    \subsubsection*{Formal Definition:}
    
    \begin{minipage}[t]{0.48\textwidth}
    \underline{Non-Terminals:}
    \begin{align*}
    N = \{ & \text{Program, Declarations,} \\
           & \text{Declaration, TypeSpec,} \\
           & \text{Scope, Statement,} \\
           & \text{LValue, Expression,} \\
           & \text{LogicalExpr, ComparisonExpr,} \\
           & \text{AdditiveExpr, MultiplicativeExpr,} \\
           & \text{UnaryExpr, PrimaryExpr,} \\
           & \text{LiteralValue, IdList, ExprList,} \\
           & \text{OutputExprList, OutputExpression,} \\
           & \text{OutputAdditiveExpr,} \\
           & \text{OutputMultiplicativeExpr,} \\
           & \text{OutputPrimaryExpr} \}
    \end{align*}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
    \underline{Terminals:}
    \begin{align*}
    T = \{ & \text{``MainPrgm'', ``Var'', ``BeginPg'', ``EndPg'',} \\
           & \text{``let'', ``@define'', ``Const'', ``if'', ``then'',} \\
           & \text{``else'', ``do'', ``while'', ``for'', ``from'',} \\
           & \text{``to'', ``step'', ``input'', ``output'', ``Int'',} \\
           & \text{``Float'', } \mathit{Id}, \mathit{Int}, \mathit{Float}, \mathit{String}, \\
           & \text{``;'', ``,'', ``:'', ``['', ``]'', ``('', ``)'',} \\
           & \text{``\{'', ``\}'', ``:='', ``='', ``+'', ``-''} \\
           & \text{``*'', ``/'', ``>'', ``<'', ``>='', ``<='',} \\
           & \text{``=='', ``!='', ``AND'', ``OR'', ``!''} \}
    \end{align*}
    \end{minipage}
    
    \vspace{5mm}
    \noindent\textbf{Production Rules (P):}
    \begin{align*}
    \text{Program} &\rightarrow \text{``MainPrgm'' } \mathit{Id} \text{ ``;'' ``Var'' } \text{Declarations} \\
                  &\quad \text{``BeginPg'' } \text{Scope} \text{ ``EndPg'' ``;''} \\
    \text{Declarations} &\rightarrow \text{Declaration}^* \\
    \text{Declaration} &\rightarrow \text{``let'' } \text{IdList} \text{ ``:'' } \text{TypeSpec} \text{ ``;''} \\
                     &\mid \text{``let'' } \text{IdList} \text{ ``:'' ``['' } \text{TypeSpec} \text{ ``;'' } \mathit{Int} \text{ ``]'' ``;''} \\
                     &\mid \text{``let'' } \text{IdList} \text{ ``:'' } \text{TypeSpec} \text{ ``='' } \text{Expression} \text{ ``;''} \\
                     &\mid \text{``let'' } \text{IdList} \text{ ``:'' ``['' } \text{TypeSpec} \text{ ``;'' } \mathit{Int} \text{ ``]''} \\
                     &\quad \text{ ``='' ``\{'' } \text{ExprList} \text{ ``\}'' ``;''} \\
                     &\mid \text{``@define'' ``Const'' } \mathit{Id} \text{ ``:'' } \text{TypeSpec} \\
                     &\quad \text{ ``='' } \text{LiteralValue} \text{ ``;''} \\
    \text{TypeSpec} &\rightarrow \text{``Int''} \mid \text{``Float''} \\
    \text{Scope} &\rightarrow \text{``\{'' } \text{Statement}^* \text{ ``\}''} \\
    \text{Statement} &\rightarrow \text{LValue} \text{ ``:='' } \text{Expression} \text{ ``;''} \\
                   &\mid \text{``if'' ``('' } \text{Expression} \text{ ``)'' ``then'' } \text{Scope} \\
                   &\quad [\text{``else'' } \text{Scope}] \\
                   &\mid \text{``do'' } \text{Scope} \text{ ``while'' ``('' } \text{Expression} \text{ ``)'' ``;''} \\
                   &\mid \text{``for'' } \text{LValue} \text{ ``from'' } \text{Expression} \\
                   &\quad \text{ ``to'' } \text{Expression} \text{ ``step'' } \text{Expression} \text{ Scope} \\
                   &\mid \text{``input'' ``('' } \text{LValue} \text{ ``)'' ``;''} \\
                   &\mid \text{``output'' ``('' } \text{OutputExprList} \text{ ``)'' ``;''} \\
    \text{LValue} &\rightarrow \mathit{Id} \\
                 &\mid \mathit{Id} \text{ ``['' } \text{Expression} \text{ ``]''} \\
    \text{Expression} &\rightarrow \text{LogicalExpr} \\
    \text{LogicalExpr} &\rightarrow \text{ComparisonExpr} \\
                      &\quad \{ \text{(``OR'' $\mid$ ``AND'') } \text{ComparisonExpr} \} \\
    \text{ComparisonExpr} &\rightarrow \text{AdditiveExpr} \\
                         &\quad \{ \text{(``=='' $\mid$ ``!='' $\mid$ ``<'' $\mid$ ``>'' $\mid$ ``<='' $\mid$ ``>='')} \\
                         &\quad \text{AdditiveExpr} \} \\
    \text{AdditiveExpr} &\rightarrow \text{MultiplicativeExpr} \\
                       &\quad \{ \text{(``+'' $\mid$ ``-'') } \text{MultiplicativeExpr} \} \\
    \text{MultiplicativeExpr} &\rightarrow \text{UnaryExpr} \\
                             &\quad \{ \text{(``*'' $\mid$ ``/'') } \text{UnaryExpr} \} \\
    \text{UnaryExpr} &\rightarrow [\text{``!''}] \text{PrimaryExpr} \\
    \text{PrimaryExpr} &\rightarrow \mathit{Id} \\
                     &\mid \mathit{Id} \text{ ``['' } \text{Expression} \text{ ``]''} \\
                     &\mid \text{LiteralValue} \\
                     &\mid \text{``('' } \text{Expression} \text{ ``)''} \\
    \text{LiteralValue} &\rightarrow \mathit{Int} \mid \mathit{Float} \mid \mathit{String} \\
    \text{IdList} &\rightarrow \mathit{Id} \{ \text{``,'' } \mathit{Id} \} \\
    \text{ExprList} &\rightarrow \text{Expression} \{ \text{``,'' } \text{Expression} \} \\
    \text{OutputExprList} &\rightarrow [ \text{OutputExpression} \\
                         &\quad \{ \text{``,'' } \text{OutputExpression} \} ] \\
    \text{OutputExpression} &\rightarrow \mathit{String} \\
                          &\mid \text{OutputAdditiveExpr} \\
    \text{OutputAdditiveExpr} &\rightarrow \text{OutputMultiplicativeExpr} \\
                             &\quad \{ \text{(``+'' $\mid$ ``-'') } \text{OutputMultiplicativeExpr} \} \\
    \text{OutputMultiplicativeExpr} &\rightarrow \text{OutputPrimaryExpr} \\
                                  &\quad \{ \text{(``*'' $\mid$ ``/'') } \text{OutputPrimaryExpr} \} \\
    \text{OutputPrimaryExpr} &\rightarrow \mathit{Id} \\
                           &\mid \mathit{Id} \text{ ``['' } \text{Expression} \text{ ``]''} \\
                           &\mid \text{LiteralValue} \\
                           &\mid \text{``('' } \text{OutputAdditiveExpr} \text{ ``)''}
    \end{align*}
    
    
    \noindent\textbf{Key Features:}
    \begin{itemize}
        \item LR(1) parsing compatible
        \item Type-aware productions
        \item Explicit scoping rules
        \item Complete expression hierarchy
        \item Array support in declarations
        \item Input/output operations
        \item Control flow constructs
        \item Constant definitions
    \end{itemize}


\subsection{Grammar Specification with LALRPOP}
LALRPOP uses LR(1) parsing techniques to analyze program structure. The grammar for MiniSoft is specified in a declarative format.

\begin{lstlisting}[caption={Grammar File Structure}]
grammar<'input>;

// External token type from our Logos lexer
extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "MainPrgm" => Token::MainPrgm,
        "BeginPg" => Token::BeginPg,
        // More tokens defined...
    }
}
\end{lstlisting}

Production rules define how language constructs are formed from simpler elements:

\begin{lstlisting}[caption={Program Rule Example}]
// Program rule (entry point)
pub Program: Located<Program> = {
    <l:@L> "MainPrgm" <name:Id> ";" "Var" "BeginPg" <stmts:Scope> "EndPg" ";" <r:@R> => {
        Located {
            node: Program {
                name,
                declarations: vec![],
                statements: stmts,
            },
            span: l..r,
        }
    },
    // Alternative with declarations
}
\end{lstlisting}

\subsection{Abstract Syntax Tree Design}
The Abstract Syntax Tree (AST) is a hierarchical representation of the program that serves as the foundation for subsequent compilation phases.

\begin{lstlisting}[caption={Core AST Structures}]
#[derive(Debug, Clone, PartialEq)]
pub struct Located<T> {
    pub node: T,
    pub span: Range<usize>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Program {
    pub name: String,
    pub declarations: Vec<Declaration>,
    pub statements: Vec<Statement>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum StatementKind {
    Assignment(Expression, Expression),
    IfThen(Expression, Vec<Statement>),
    IfThenElse(Expression, Vec<Statement>, Vec<Statement>),
    DoWhile(Vec<Statement>, Expression),
    For(Expression, Expression, Expression, Expression, Vec<Statement>),
    Input(Expression),
    Output(Vec<Expression>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum ExpressionKind {
    Identifier(String),
    ArrayAccess(String, Box<Expression>),
    Literal(Literal),
    BinaryOp(Box<Expression>, Operator, Box<Expression>),
    UnaryOp(UnaryOperator, Box<Expression>),
}
\end{lstlisting}

Each element in the AST is wrapped in a \texttt{Located<T>} structure that contains both the node and its position in the source code.

\subsection{Expression Grammar}
MiniSoft's expression grammar defines how expressions are parsed with proper operator precedence:

\begin{lstlisting}[caption={Expression Grammar Example}]
// Expression rules with precedence
Expression: Located<ExpressionKind> = {
    LogicalExpr,
};

LogicalExpr: Located<ExpressionKind> = {
    <l:@L> <lhs:LogicalExpr> "OR" <rhs:ComparisonExpr> <r:@R> => {
        Located {
            node: ExpressionKind::BinaryOp(Box::new(lhs), Operator::Or, Box::new(rhs)),
            span: l..r,
        }
    },
    ComparisonExpr,
};

// Lower precedence rules would follow...
\end{lstlisting}

This grammar ensures operators are evaluated in the correct precedence order, from highest to lowest:
\begin{enumerate}
	\item Parenthesized expressions and primary expressions
	\item Unary operators
	\item Multiplicative operators (*, /)
	\item Additive operators (+, -)
	\item Comparison operators (==, !=, <, >, <=, >=)
	\item Logical operators (AND, OR)
\end{enumerate}

\subsection{Error Handling and Reporting}
The parser detects and reports the first encountered syntax error with detailed feedback, then immediately terminates compilation to ensure prompt error resolution.
\begin{lstlisting}[caption={Syntax Error Types}]
#[derive(Debug)]
pub enum SyntaxError {
    InvalidToken {
        position: usize,
        message: String,
        line: usize,
        column: usize,
    },
    UnexpectedEOF {
        position: usize,
        expected: Vec<String>,
        line: usize,
        column: usize,
    },
    UnexpectedToken {
        token: String,
        position: (usize, usize),
        expected: Vec<String>,
        line: usize,
        column: usize,
    },
    // Other error types...
}
\end{lstlisting}

This produces clear error output:

\begin{lstlisting}[caption={Syntax Error Output}]
Syntax Error: Unexpected token '}'
--> line 15, column 3
  |
15 | if (x > 10) then {
  |   output("Value too large");
  | }
  |   ^
Expected one of: ';'
Suggestion: Missing semicolon at the end of statement before this closing brace
\end{lstlisting}

\section{Semantic Analysis}
\subsection{Overview of Semantic Analysis}
Semantic analysis ensures that the program follows logical rules beyond syntax. In MiniSoft, this phase performs:

\begin{itemize}
	\item Type checking for operations and assignments
	\item Identification of undeclared or multiply-declared variables
	\item Validation of constant integrity
	\item Detection of array bounds violations
	\item Recognition of potential runtime errors at compile time
	\item Verification of control flow constructs
\end{itemize}

\subsection{Symbol Table Management}
The symbol table tracks program identifiers and their attributes:

\begin{lstlisting}[caption={Symbol Table Structure}]
#[derive(Debug, Clone, PartialEq)]
pub enum SymbolKind {
    Variable,
    Constant,
    Array(usize),
}

#[derive(Debug, Clone)]
pub struct Symbol {
    pub name: String,           // Identifier name
    pub kind: SymbolKind,       // Variable, constant, or array
    pub symbol_type: Type,      // Data type (Int, Float, etc.)
    pub value: SymbolValue,     // Current value (if known at compile time)
    pub is_constant: bool,      // Whether the symbol can be modified
    pub line: usize,            // Declaration line number
    pub column: usize,          // Declaration column number
}
\end{lstlisting}


\subsection{Semantic Analyzer Modules}

The semantic analyzer delegates specific tasks to three specialized modules:

\subsubsection{Declaration Analyzer}

\textbf{Responsibilities:}
\begin{itemize}
    \item Handles variable, array, and constant declarations
    \item Validates and registers entities in the symbol table
\end{itemize}

\textbf{Key Functions:}
\begin{itemize}
    \item \texttt{handle\_variable\_declaration}: Validates variables without initial values
    \item \texttt{handle\_variable\_declaration\_with\_init}: Validates initialized variables
    \item \texttt{handle\_constant\_declaration}: Validates constants
    \item \texttt{handle\_array\_declaration}: Validates array declarations
    \item \texttt{handle\_array\_declaration\_with\_init}: Validates initialized arrays
\end{itemize}

\textbf{Errors Handled:}
\begin{itemize}
    \item Duplicate declarations
    \item Type mismatches
    \item Array size mismatches
\end{itemize}

\subsubsection{Statement Analyzer}

\textbf{Responsibilities:}
\begin{itemize}
    \item Analyzes program statements
    \item Handles assignments, control flow, and I/O operations
\end{itemize}

\textbf{Key Functions:}
\begin{itemize}
    \item \texttt{handle\_assignment}: Validates assignments
    \item \texttt{handle\_condition}: Analyzes control flow conditions
    \item \texttt{handle\_scope}: Analyzes statement blocks
    \item \texttt{handle\_forloop}: Analyzes for loops
    \item \texttt{handle\_input/output}: Validates I/O operations
\end{itemize}

\textbf{Errors Handled:}
\begin{itemize}
    \item Type mismatches
    \item Invalid identifiers
    \item Non-boolean conditions
    \item Constant modification
\end{itemize}

\subsubsection{Expression Analyzer}

\textbf{Responsibilities:}
\begin{itemize}
    \item Analyzes expressions
    \item Handles literals, identifiers, and operations
\end{itemize}

\textbf{Key Functions:}
\begin{itemize}
    \item \texttt{handle\_identifier}: Validates identifiers
    \item \texttt{handle\_array\_access}: Validates array accesses
    \item \texttt{handle\_literal}: Processes literals
    \item \texttt{handle\_binary/unary\_operation}: Analyzes operations
\end{itemize}

\textbf{Errors Handled:}
\begin{itemize}
    \item Undeclared identifiers
    \item Array bounds errors
    \item Type mismatches
    \item Division by zero
\end{itemize}

\subsubsection{Integration Workflow}

\begin{enumerate}
    \item First pass: Analyze declarations (populate symbol table)
    \item Second pass: Analyze statements (semantic validation)
\end{enumerate}

The modular design ensures organized, maintainable analysis with clear separation of concerns.

\subsection{Type System Implementation}
MiniSoft features a static type system enforcing type compatibility at compile time:

\begin{lstlisting}[caption={Type System}]
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Int,
    Float,
    String,
}

impl Type {
    pub fn is_compatible_with(&self, target: &Type) -> bool {
        match (self, target) {
            // Same types are always compatible
            (Type::Int, Type::Int) => true,
            (Type::Float, Type::Float) => true,
            (Type::String, Type::String) => true,
            
            // All other combinations are incompatible
            _ => false,
        }
    }
}
\end{lstlisting}

\subsection{Expression Evaluation}
The \texttt{expression\_analyzer} module evaluates and analyzes expressions during semantic analysis, ensuring semantic validity, type rule adherence, and performing constant folding where possible.

\subsubsection*{Key Concepts}
\begin{itemize}
    \item \textbf{Expression Types}:
    \begin{itemize}
        \item Literals (constants like integers, floats, strings)
        \item Identifiers (variables/constants by name)
        \item Array Access (elements accessed by index)
        \item Binary Operations (two operands, e.g., +, -)
        \item Unary Operations (single operand, e.g., !)
    \end{itemize}
    
    \item \textbf{ValueType}:
    \begin{itemize}
        \item \texttt{typ}: Expression type (Int, Float)
        \item \texttt{value}: Evaluated value (if compile-time known)
    \end{itemize}
\end{itemize}

\subsubsection*{Evaluation Workflow}
\begin{itemize}
    \item \texttt{analyze\_expression}: Dispatches to appropriate handler:
    \begin{itemize}
        \item Identifiers $\rightarrow$ \texttt{handle\_identifier}
        \item Array Access $\rightarrow$ \texttt{handle\_array\_access}
        \item Literals $\rightarrow$ \texttt{handle\_literal}
        \item Binary Ops $\rightarrow$ \texttt{handle\_binary\_operation}
        \item Unary Ops $\rightarrow$ \texttt{handle\_unary\_operation}
    \end{itemize}
\end{itemize}

\subsubsection*{Expression Handlers}
\begin{enumerate}
    \item \textbf{Identifiers}
    \begin{itemize}
        \item Function: \texttt{handle\_identifier}
        \item Purpose: Validates existence in symbol table
        \item Errors: Undeclared identifier
        \item Example:
        \begin{lstlisting}
let x = 5;  // x resolves to Int with value 5
        \end{lstlisting}
    \end{itemize}
    
    \item \textbf{Array Access}
    \begin{itemize}
        \item Function: \texttt{handle\_array\_access}
        \item Errors: Undeclared, OOB, non-array, index type
        \item Example:
        \begin{lstlisting}
let arr = [1, 2, 3];
let x = arr[1];  // Int with value 2
        \end{lstlisting}
    \end{itemize}
    
    \item \textbf{Literals}
    \begin{itemize}
        \item Function: \texttt{handle\_literal}
        \item Example:
        \begin{lstlisting}
let x = 42;    // Int(42)
let y = 3.14;  // Float(3.14)
        \end{lstlisting}
    \end{itemize}
    
    \item \textbf{Binary Operations}
    \begin{itemize}
        \item Function: \texttt{handle\_binary\_operation}
        \item Operators: +, -, *, /, <, >, ==, !=, \&\&, ||
        \item Errors: Type mismatch, division by zero
        \item Example:
        \begin{lstlisting}
let x = 5 + 3;   // Int(8)
let y = 10 / 0;  // Error
        \end{lstlisting}
    \end{itemize}
    
    \item \textbf{Unary Operations}
    \begin{itemize}
        \item Function: \texttt{handle\_unary\_operation}
        \item Operators: !
        \item Errors: Invalid logical values
        \item Example:
        \begin{lstlisting}
let x = !1;  // Int(0)
let y = !5;  // Error
        \end{lstlisting}
    \end{itemize}
\end{enumerate}


\subsubsection*{Constant Folding}
Evaluates constant expressions at compile time:
\begin{itemize}
    \item \texttt{5 + 3} $\rightarrow$ \texttt{8}
    \item \texttt{10 / 2} $\rightarrow$ \texttt{5}
\end{itemize}


\subsection{Error Detection and Reporting}
The semantic analyzer performs comprehensive validation, detecting and collecting all semantic errors (type mismatches, undefined variables, scope violations, etc.) before reporting them collectively to allow for batch fixes.
\begin{lstlisting}[caption={Semantic Error Types}]
#[derive(Debug)]
pub enum SemanticError {
    ArraySizeMismatch { name: String, expected: usize, actual: usize },
    UndeclaredIdentifier { name: String },
    DuplicateDeclaration { name: String, original_line: usize },
    TypeMismatch { expected: String, found: String, context: Option<String> },
    DivisionByZero { },
    ConstantModification { name: String },
    ArrayIndexOutOfBounds { name: String, index: usize, size: usize },
    // Other error types...
}
\end{lstlisting}

Example of error output:

\begin{lstlisting}[caption={Semantic Error Output}]
Semantic Error: Type mismatch in assignment: expected Int, found Float
--> line 12, column 3
  |
12 |   result := average;
  |   ^^^^^^
Suggestion: Make sure the types match. Try converting from 'Float' to 'Int'
\end{lstlisting}

\section{Code Generation}
\subsection{Intermediate Representation}
The MiniSoft compiler uses quadruples as an intermediate representation that bridges the gap between the AST and machine-level instructions:

\begin{lstlisting}[caption={Quadruple Structure}]
#[derive(Debug, Clone, PartialEq)]
pub enum Operation {
    // Arithmetic operations
    Add, Subtract, Multiply, Divide,
    
    // Assignment and memory operations
    Assign, ArrayStore, ArrayLoad,
    
    // Control flow operations
    Label(usize), Jump(usize), JumpIfTrue(usize), JumpIfFalse(usize),
    
    // Comparison and logical operations
    Equal, NotEqual, LessThan, And, Or, Not,
    
    // I/O operations
    Input, Output,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Operand {
    IntLiteral(i32),
    FloatLiteral(f32),
    StringLiteral(String),
    Variable(String),
    TempVariable(String),
    ArrayElement(String, Box<Operand>),
    Empty,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Quadruple {
    pub operation: Operation,
    pub operand1: Operand,
    pub operand2: Operand,
    pub result: Operand,
}
\end{lstlisting}

\subsection{Code Generation Strategy}
The MiniSoft compiler generates code through recursive traversal of the AST:

\begin{lstlisting}[caption={Expression Code Generation}]
fn generate_expression(&mut self, expr: &Expression) -> Operand {
    match &expr.node {
        // For simple identifiers, just return a reference
        ExpressionKind::Identifier(name) => Operand::Variable(name.clone()),
        
        // For binary operations, process both operands
        ExpressionKind::BinaryOp(left, op, right) => {
            let left_result = self.generate_expression(left);
            let right_result = self.generate_expression(right);
            let result = self.program.new_temp();

            // Map AST operator to quadruple operation
            let operation = match op {
                Operator::Add => Operation::Add,
                Operator::Subtract => Operation::Subtract,
                // Other operators...
            };

            self.program.add(Quadruple {
                operation,
                operand1: left_result,
                operand2: right_result,
                result: result.clone(),
            });

            result
        },
        
        // Other expression types...
    }
}
\end{lstlisting}

For control structures like if-statements, the code generator creates labels and jumps:

\begin{lstlisting}[caption={If-Statement Code Generation}]
// Example of if-then-else statement
match &statement.node {
    StatementKind::IfThenElse(condition, then_block, else_block) => {
        let else_label = self.program.new_label();
        let end_label = self.program.new_label();
        
        // Evaluate condition
        let cond_result = self.generate_expression(condition);
        
        // Jump to else if condition is false
        self.program.add(Quadruple {
            operation: Operation::JumpIfFalse(else_label),
            operand1: cond_result,
            operand2: Operand::Empty,
            result: Operand::Empty,
        });
        
        // Generate code for then block
        // ...
    }
}
\end{lstlisting}

\subsection{Example of Generated Code}
For a simple MiniSoft program with a loop:

\begin{lstlisting}[caption={Sample MiniSoft Program}]
MainPrgm LoopExample;
Var
  let i: Int;
  let sum: Int;
BeginPg
{
  i := 1;
  sum := 0;
  
  while (i <= 10) do {
    sum := sum + i;
    i := i + 1;
  }
  
  output(sum);  // Outputs: 55
}
EndPg;
\end{lstlisting}

The generated quadruples would be:

\begin{lstlisting}[caption={Generated Quadruples}]
(ASSIGN, 1, _, i)             // i := 1
(ASSIGN, 0, _, sum)          // sum := 0
(LABEL_1, _, _, _)           // Start of loop
(LE, i, 10, t1)              // Compare i <= 10
(JMPF_2, t1, _, _)           // Jump to label 2 if false
(ADD, sum, i, t2)            // Calculate sum + i
(ASSIGN, t2, _, sum)         // sum := sum + i
(ADD, i, 1, t3)              // Calculate i + 1
(ASSIGN, t3, _, i)           // i := i + 1
(JUMP_1, _, _, _)            // Jump back to start
(LABEL_2, _, _, _)           // End of loop
(OUTPUT, sum, _, _)          // Output sum
\end{lstlisting}

\section{Error Handling}
\subsection{Error Categories}
The MiniSoft compiler implements comprehensive error detection across all compilation phases:

\begin{enumerate}
	\item \textbf{Lexical Errors}: Invalid characters or token formation issues
	\item \textbf{Syntax Errors}: Violations of grammar rules
	\item \textbf{Semantic Errors}: Logically invalid constructs
	\item \textbf{Code Generation Errors}: Issues in the final translation phase
\end{enumerate}

\subsection{Error Reporting Framework}
The compiler uses a unified error reporting framework based on the \texttt{ErrorReporter} trait:

\begin{lstlisting}[caption={Error Reporter Interface}]
pub trait ErrorReporter {
    fn report(&self, source_code: Option<&str>) -> String;
    fn get_suggestion(&self) -> Option<String>;
    fn get_error_name(&self) -> String;
    fn get_location_info(&self) -> (usize, usize);
}
\end{lstlisting}

This ensures consistent error presentation across all compiler phases.

\subsection{Source Code Context}
Error messages include source code context with visual indicators:

\begin{lstlisting}[caption={Error with Source Context}]
Syntax Error: Unexpected token '}'
--> line 15, column 3
  |
15 | if (x > 10) then {
  |   output("Value too large");
  | }
  |   ^
Expected one of: ';'
Suggestion: Missing semicolon at the end of statement before this closing brace
\end{lstlisting}

\subsection{Example Error Scenarios}
The compiler detects various error types:

\begin{lstlisting}[caption={Lexical Error Example}]
Lexical Error: Identifier 'veryLongIdentifier' exceeds maximum length of 14 characters
--> line 3, column 7
  |
3 |   let veryLongIdentifier: Int;
  |       ^^^^^^^^^^^^^^^^^^
Suggestion: Identifiers must be 14 characters or less
\end{lstlisting}

\begin{lstlisting}[caption={Semantic Error Example}]
Semantic Error: Type mismatch in assignment: expected Int, found String
--> line 7, column 3
  |
7 |   x := message;
  |   ^
Suggestion: Cannot assign a String value to an Int variable.
\end{lstlisting}

\begin{lstlisting}[caption={Compile-Time Error Example}]
Semantic Error: Division by zero detected in constant expression
--> line 7, column 14
  |
7 |   result := 10 / DIVISOR;
  |              ^^^^^^^^^
Suggestion: Check the divisor value to ensure it is not zero
\end{lstlisting}

\section{Testing and Validation}
\subsection{Test Methodology}
The MiniSoft compiler was tested using a comprehensive suite of test cases designed to verify functionality across all compilation phases. Tests were developed using both black-box and white-box approaches to ensure complete coverage.
\subsection{Test Cases}
The test suite includes unit tests for individual components and integration tests for the complete compilation pipeline:

\section{Results and Evaluation}
\subsection{Functionality Assessment}
The MiniSoft compiler successfully implements all required language features and compilation phases. It correctly handles a wide range of program constructs while providing meaningful error messages for invalid code.

\subsection{Example Compilation}
Here is a complete compilation example of a factorial program:

\begin{lstlisting}[caption={Sample MiniSoft Program}]
MainPrgm Factorial;
Var
  let n: Int;
  let result: Int;
BeginPg
{
  n := 5;
  result := 1;
  
  for i from 1 to n step 1 {
    result := result * i;
  }
  
  output(result);  // Outputs: 120
}
EndPg;
\end{lstlisting}

\section{Conclusion}
\subsection{Achievements}
The MiniSoft compiler successfully implements a complete compilation pipeline that translates MiniSoft source code into  quadruples format. Key achievements include:

\begin{itemize}
	\item A robust lexical analyzer using Logos
	\item A comprehensive syntax analyzer using LALRPOP
	\item A thorough semantic analyzer with type checking
	\item An intermediate code generator using quadruples
	\item A detailed error reporting system
\end{itemize}

\subsection{Challenges}
Challenges encountered during implementation included:
\begin{itemize}
	\item Designing an error recovery strategy that balances robustness with usability
	\item Implementing proper type checking for a statically typed language
	\item Handling complex control flow structures in code generation
	\item Creating clear, actionable error messages
\end{itemize}

\subsection{Future Improvements}
Potential future enhancements include:
\begin{itemize}
    \item Add executable generation (binary/bytecode output)
	\item Additional optimization passes
	\item Support for functions and procedures
	\item Enhanced type system with type conversion
	\item Improved warning system for potential issues
	\item IDE integration for interactive development
\end{itemize}


\begin{thebibliography}{9}
	\bibitem{rust} The Rust Programming Language: \url{https://www.rust-lang.org/}
	\bibitem{logos} Logos: \url{https://logos.maciej.codes/}
	\bibitem{lalrpop} LALRPOP: \url{https://lalrpop.github.io/lalrpop/}
	\bibitem{cranelift} Cranelift: \url{https://docs.rs/cranelift/latest/cranelift/}
\end{thebibliography}

\end{document}
