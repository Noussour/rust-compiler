// This file uses LALRPOP to define the parser grammar for our language.

use std::str::FromStr;
use crate::lexer::token::Token;
use crate::parser::ast::{Span, Located, Program, Declaration, Statement, Expression, Operator, UnaryOperator, Type, Literal};

grammar<'input>;

// External token type from our Logos lexer
extern {
    type Location = usize;
    type Error = String;

    enum Token {
        // Language keywords
        "MainPrgm" => Token::MainPrgm,
        "Var" => Token::Var,
        "BeginPg" => Token::BeginPg,
        "EndPg" => Token::EndPg,
        "let" => Token::Let,
        "Int" => Token::Int,
        "Float" => Token::Float,
        
        // Control flow
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "while" => Token::While,
        "for" => Token::For,
        "do" => Token::Do,
        "from" => Token::From,
        "to" => Token::To,
        "step" => Token::Step,
        
        // I/O operations
        "input" => Token::Input,
        "output" => Token::Output,
        "@define" => Token::Define,
        "Const" => Token::Const,
        
        // Punctuation
        ";" => Token::Semicolon,
        "," => Token::Comma,
        ":" => Token::Colon,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        
        // Assignment
        ":=" => Token::Assign,
        "=" => Token::Equals,
        
        // Arithmetic operators
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        
        // Comparison operators
        ">" => Token::GreaterThan,
        "<" => Token::LessThan,
        ">=" => Token::GreaterEqual,
        "<=" => Token::LessEqual,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        
        // Logical operators
        "AND" => Token::And,
        "OR" => Token::Or,
        "!" => Token::Not,
        
        // Literals and identifiers
        Int => Token::IntLiteral(<i32>),
        Float => Token::FloatLiteral(<f32>),
        String => Token::StringLiteral(<String>),
        Idf => Token::Identifier(<String>),  // Renamed to avoid conflict
    }
}

// Program rule (entry point) - defines the main structure (name, declarations, statements).
pub Program: Located<Program> = {
    <l:@L> "MainPrgm" <name:Id> ";" "Var" <decls:Declaration*> "BeginPg" <stmts:Block> "EndPg" ";" <r:@R> =>  {
        Located {
            node: Program {
                name,
                declarations: decls.into_iter().map(|loc| loc.node).collect(),
                statements: stmts.into_iter().map(|loc| loc.node).collect(),
            },
            span: Span { start: l, end: r },
        }
    },
};

// Declaration rules: Manage different ways to declare variables, arrays, and constants.
Declaration: Located<Declaration> = {
    <l:@L> "let" <names:IdList> ":" <ty:TypeSpec> ";" <r:@R> => {
        Located {
            node: Declaration::Variable(names, ty),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "let" <names:IdList> ":" "[" <ty:TypeSpec> ";" <size:Int> "]" ";" <r:@R> => {
        Located {
            node: Declaration::Array(names, ty, size as usize),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "let" <names:IdList> ":" <ty:TypeSpec> "=" <value:Expression> ";" <r:@R> => {
        Located {
            node: Declaration::VariableWithInit(names, ty, value.node),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "let" <names:IdList> ":" "[" <ty:TypeSpec> ";" <size:Int> "]" "=" "{" <values:ExprList>"}" ";" <r:@R> => {
        Located {
            node: Declaration::ArrayWithInit(names, ty, size as usize, values.into_iter().map(|loc| loc.node).collect()),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "@define" "Const" <name:Id> ":" <ty:TypeSpec> "=" <value:LiteralValue> ";" <r:@R> => {
        Located {
            node: Declaration::Constant(name, ty, value),
            span: Span { start: l, end: r },
        }
    }
};

// Type specification - specifies possible data types like Int and Float.
TypeSpec: Type = {
    "Int" => Type::Int,
    "Float" => Type::Float,
};

Block: Vec<Located<Statement>> = {
    "{" <stmts:Statement*> "}" => stmts,
};

// Statement rules - define different control flow and I/O statements.
Statement: Located<Statement> = {
    <l:@L> <target:LValue> ":=" <value:Expression> ";" <r:@R> => {
        Located {
            node: Statement::Assignment(target.node, value.node),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "if" "(" <cond:Expression> ")" "then" <then_block:Block> <r:@R> => {
        Located {
            node: Statement::IfThen(cond.node, then_block.into_iter().map(|loc| loc.node).collect()),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "if" "(" <cond:Expression> ")" "then" <then_block:Block> "else" <else_block:Block> <r:@R> => {
        Located {
            node: Statement::IfThenElse(
                cond.node, 
                then_block.into_iter().map(|loc| loc.node).collect(),
                else_block.into_iter().map(|loc| loc.node).collect()
            ),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "do" <body:Block> "while" "(" <cond:Expression> ")" ";" <r:@R> => {
        Located {
            node: Statement::DoWhile(body.into_iter().map(|loc| loc.node).collect(), cond.node),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "for" <var:Id> "from" <from:Expression> "to" <to:Expression> "step" <step:Expression> <body:Block> <r:@R> => {
        Located {
            node: Statement::For(
                var, 
                from.node, 
                to.node, 
                step.node, 
                body.into_iter().map(|loc| loc.node).collect()
            ),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "input" "(" <var:LValue> ")" ";" <r:@R> => {
        Located {
            node: Statement::Input(var.node),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> "output" "(" <exprs:OutputExprList> ")" ";" <r:@R> => {
        Located {
            node: Statement::Output(exprs.into_iter().map(|loc| loc.node).collect()),
            span: Span { start: l, end: r },
        }
    },
};

// LValue rule: Determines valid left-hand side targets in assignments, like identifiers or array elements.
LValue: Located<Expression> = {
    <l:@L> <id:Id> <r:@R> => Located {
        node: Expression::Identifier(id),
        span: Span { start: l, end: r },
    },
    <l:@L> <id:Id> "[" <idx:Expression> "]" <r:@R> => Located {
        node: Expression::ArrayAccess(id, Box::new(idx.node)),
        span: Span { start: l, end: r },
    },
};

// Expression rules
Expression: Located<Expression> = {
    LogicalExpr,
};

LogicalExpr: Located<Expression> = {
    <l:@L> <lhs:LogicalExpr> "OR" <rhs:ComparisonExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::Or, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:LogicalExpr> "AND" <rhs:ComparisonExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::And, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    ComparisonExpr,
};

ComparisonExpr: Located<Expression> = {
    <l:@L> <lhs:ComparisonExpr> "==" <rhs:AdditiveExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::Equal, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:ComparisonExpr> "!=" <rhs:AdditiveExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::NotEqual, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:ComparisonExpr> "<" <rhs:AdditiveExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::LessThan, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:ComparisonExpr> ">" <rhs:AdditiveExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::GreaterThan, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:ComparisonExpr> "<=" <rhs:AdditiveExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::LessEqual, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:ComparisonExpr> ">=" <rhs:AdditiveExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::GreaterEqual, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    AdditiveExpr,
};

AdditiveExpr: Located<Expression> = {
    <l:@L> <lhs:AdditiveExpr> "+" <rhs:MultiplicativeExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::Add, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:AdditiveExpr> "-" <rhs:MultiplicativeExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::Subtract, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    MultiplicativeExpr,
};

MultiplicativeExpr: Located<Expression> = {
    <l:@L> <lhs:MultiplicativeExpr> "*" <rhs:UnaryExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::Multiply, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    <l:@L> <lhs:MultiplicativeExpr> "/" <rhs:UnaryExpr> <r:@R> => {
        Located {
            node: Expression::BinaryOp(Box::new(lhs.node), Operator::Divide, Box::new(rhs.node)),
            span: Span { start: l, end: r },
        }
    },
    UnaryExpr,
};

UnaryExpr: Located<Expression> = {
    <l:@L> "!" <expr:PrimaryExpr> <r:@R> => {
        Located {
            node: Expression::UnaryOp(UnaryOperator::Not, Box::new(expr.node)),
            span: Span { start: l, end: r },
        }
    },
    PrimaryExpr,
};

PrimaryExpr: Located<Expression> = {
    <l:@L> <id:Id> <r:@R> => Located {
        node: Expression::Identifier(id),
        span: Span { start: l, end: r },
    },
    <l:@L> <id:Id> "[" <idx:Expression> "]" <r:@R> => Located {
        node: Expression::ArrayAccess(id, Box::new(idx.node)),
        span: Span { start: l, end: r },
    },
    <l:@L> <lit:LiteralValue> <r:@R> => Located {
        node: Expression::Literal(lit),
        span: Span { start: l, end: r },
    },
    "(" <expr:Expression> ")" => expr,
};

// Literal values - parse integer, float, and string constants.
LiteralValue: Literal = {
    <n:Int> => Literal::Int(n),
    <f:Float> => Literal::Float(f),
};

// Helper rules for comma-separated lists
IdList: Vec<String> = {
    <v:(<Id> ",")*> <e:Id> => {
        let mut v = v;
        v.push(e);
        v
    }
};

ExprList: Vec<Located<Expression>> = {
    <v:(<Expression> ",")*> <e:Expression> => {
        let mut v = v;
        v.push(e);
        v
    },
    => vec![],
};

// Helper rules
Id: String = {
    Idf => <>,
};

IntLiteral: i32 = {
    Int => <>,
};

FloatLiteral: f32 = {
    Float => <>,
};

StringLiteral: String = {
    String => <>,
};

// Restrict StringLiteral to only be used in the output function
OutputExprList: Vec<Located<Expression>> = {
    <v:(<OutputExpression> ",")*> <e:OutputExpression> => {
        let mut v = v;
        v.push(e);
        v
    },
    => vec![],
};

OutputExpression: Located<Expression> = {
    <l:@L> <lit:StringLiteral> <r:@R> => Located {
        node: Expression::Literal(Literal::String(lit)),
        span: Span { start: l, end: r },
    },
    <expr:Expression> => expr,
};
